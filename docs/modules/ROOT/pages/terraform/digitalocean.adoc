= Tutorial: How To Use Terraform with DigitalOcean

This tutorial is based on https://www.digitalocean.com/community/tutorials/how-to-use-terraform-with-digitalocean but differs at some points.

* The API token is passed via `terraform apply -auto-approve -var="do_token=<THE_DIGITAL_OCEAN_API_TOKEN>"` instead of exporting a bash variable.
* The variable containing the path to the private SSH key is initialized with the correct path.
* All Terraform bash commands are encapsulated inside `link:https://github.com/sebastian-sommerfeld-io/playgrounds/blob/main/src/main/terraform/tf.sh[tf.sh]` script.
* Destroying resources is done slightly different
* Terraform itself is running inside a docker container

The scripts and Terraform files related to this tutorial are stored at link:https://github.com/sebastian-sommerfeld-io/playgrounds/tree/main/src/main/terraform/digitalocean[src/main/terraform/digitalocean].

== Introduction
link:https://www.terraform.io[Terraform] is a tool for building and managing infrastructure in an organized way. You can use it to manage DigitalOcean Droplets, Load Balancers, and even DNS entries, in addition to a large variety of services offered by other providers. Terraform uses a command-line interface and can run from your desktop or a remote server.

Terraform works by reading configuration files that describe the components that make up your application environment or datacenter. Based on the configuration, it generates an execution plan that describes what it will do to reach the desired state. You then use Terraform to execute this plan to build the infrastructure. When changes to the configuration occur, Terraform can generate and execute incremental plans to update the existing infrastructure to the newly described state.

In this tutorial, you’ll install Terraform and use it to create an infrastructure on DigitalOcean that consists of two Nginx servers that are load balanced by a DigitalOcean Load Balancer. Then, you’ll use Terraform to add a DNS entry on DigitalOcean that points to your Load Balancer. This will help you get started with using Terraform, and give you an idea of how you can use it to manage and deploy a DigitalOcean-based infrastructure that meets your own needs.

=== Building Block View / Whitebox Overall System
After completing this tutorial the following setup will be in place.

[plantuml, rendered-plantuml-image, svg]
----
@startuml

skinparam linetype ortho
skinparam monochrome false
skinparam componentStyle uml2
skinparam backgroundColor transparent
skinparam ArrowColor black
skinparam FrameBackgroundColor #fff
skinparam CollectionsBackgroundColor #fefece
skinparam CollectionsBorderColor black
skinparam ComponentBorderColor black
skinparam ComponentBackgroundColor #fefece
skinparam RectangleBorderColor black
skinparam RectangleBackgroundColor #fefece
skinparam QueueBorderColor black
skinparam NoteBorderColor Grey
skinparam NoteBackgroundColor #fff
skinparam defaultTextAlignment center
skinparam activity {
  FontName Ubuntu
}

rectangle digitalocean {
    rectangle droplets {
        component www_1 as "www-1" <<digitalocean_droplet>> {
            component nginx_1
        }
        component www_2 as "www-2" <<digitalocean_droplet>> {
            component nginx_2
        }
    }
    component domain <<digitalocean_domain>>
    component loadbalancer <<digitalocean_loadbalancer>>
}

file url as "playground-digitalocean.test.sommerfeld.io"

rectangle domain_host <<some_service_provider>>
cloud internet

domain_host -right-> internet
internet -right-> domain
domain -right-> loadbalancer
loadbalancer -> droplets

www_1 -[hidden]down-> www_2

domain_host ~down~ url
domain ~down~ url

@enduml
----

== Prerequisites
To complete this tutorial, you’ll need:

. A DigitalOcean account. If you do not have one, link:https://cloud.digitalocean.com/registrations/new[sign up for a new account].
. A DigitalOcean Personal Access Token, which you can create via the DigitalOcean control panel. Instructions to do that can be found at: link:https://docs.digitalocean.com/reference/api/create-personal-access-token[How to Create a Personal Access Token].
. A password-less SSH key added to your DigitalOcean account, which you can create by following link:https://www.digitalocean.com/community/tutorials/how-to-use-ssh-keys-with-digitalocean-droplets[How To Use SSH Keys with DigitalOcean Droplets]. When you add the key to your account, remember the name you give it, as you’ll need it in this tutorial. (For Terraform to accept the name of your key, it must start with a letter or underscore and may contain only letters, digits, underscores, and dashes.)
. A personal domain pointed to DigitalOcean’s nameserver, which you can do by following the tutorial, link:https://www.digitalocean.com/community/tutorials/how-to-point-to-digitalocean-nameservers-from-common-domain-registrars[How To Point to DigitalOcean Nameservers From Common Domain Registrars].

== Step 1 — Installing Terraform
Install terraform (if not already installed). See https://learn.hashicorp.com/tutorials/terraform/install-cli for instalation instructions.

== Step 2 — Configuring Terraform for DigitalOcean
Terraform supports a variety of service providers through _providers_ you can install. Each provider has its own specifications, which generally map to the API of its respective service provider.

The link:https://registry.terraform.io/providers/digitalocean/digitalocean/latest/docs[DigitalOcean provider] lets Terraform interact with the DigitalOcean API to build out infrastructure. This provider supports creating various DigitalOcean resources, including the following:

* *digitalocean_droplet:* Droplets (servers)
* *digitalocean_loadbalancer:* Load Balancers
* *digitalocean_domain:* DNS domain entries
* *digitalocean_record:* DNS records

Terraform will use your DigitalOcean Personal Access Token to communicate with the DigitalOcean API and manage resources in your account. Don’t share this key with others, and keep it out of scripts and version control.

Terraform configurations are text files that end with the `.tf` file extension. They are human-readable and they support comments. (Terraform also supports JSON-format configuration files, but they won’t be covered here.) Terraform will read all of the configuration files in your working directory in a declarative manner, so the order of resource and variable definitions do not matter. Your entire infrastructure can exist in a single configuration file, but you should separate the configuration files by resource type to maintain clarity.

The first step to building an infrastructure with Terraform is to define the provider you’re going to use.

To use the DigitalOcean provider with Terraform, you have to tell Terraform about it and configure the plugin with the proper credential variables. Create a file called `provider.tf` in `src/main/terraform/digitalocean`, which will store the configuration for the provider:

[source, hcl-terraform]
----
terraform {
  required_providers {
    digitalocean = {
      source = "digitalocean/digitalocean"
      version = "~> 2.0"
    }
  }
}
----

The API token is read from a secrets file which is not committed to the remote repo. The token is passed  to terraform via `terraform apply -auto-approve -var="do_token=<THE_DIGITAL_OCEAN_API_TOKEN>"` (see `link:https://github.com/sebastian-sommerfeld-io/playgrounds/blob/main/src/main/terraform/tf.sh[tf.sh]`). The var-name "do_token" must match the variable from `provider.tf`.

Then, add these lines to configure the DigitalOcean provider and specify the credentials for your DigitalOcean account by assigning the do_token to the token argument of the provider:

[source, hcl-terraform]
----
# ...

variable "do_token" {}

variable "pvt_key" {
  type = string
  default = "/root/.ssh/digitalocean_droplets.key" # path inside docker container
}

provider "digitalocean" {
    token = var.do_token
}
----

Finally, you’ll want to have Terraform automatically add your SSH key to any new Droplets you create. When you added your SSH key to DigitalOcean, you gave it a name. Terraform can use this name to retrieve the public key.

[source, hcl-terraform]
----
# ...

data "digitalocean_ssh_key" "terraform" {
  name = "kobol-digitalocean-droplets" # Name from DigitalOcean web console
}
----

Your completed provider.tf file will look like this:

[source, hcl-terraform]
----
terraform {
  required_providers {
    digitalocean = {
      source = "digitalocean/digitalocean"
      version = "~> 2.0"
    }
  }
}

variable "do_token" {}

variable "pvt_key" {
  type = string
  default = "/root/.ssh/digitalocean_droplets.key" # path inside docker container
}

provider "digitalocean" {
  token = var.do_token
}

data "digitalocean_ssh_key" "terraform" {
  name = "kobol-digitalocean-droplets"
}

output "password1" {
  sensitive = true
  value = var.do_token
}

output "password2" {
  value = var.do_token
}

----

When you’re done, save and close the file. Terraform is now able to configure and can connect to your DigitalOcean account. In the next step, you’ll use Terraform to define a Droplet that will run an Nginx server.

== Step 3 — Defining the First Nginx Server
You can use Terraform to create a DigitalOcean Droplet and install software on the Droplet once it spins up. In this step, you’ll provision a single Ubuntu 20.04 Droplet and install the Nginx web server using Terraform.

Create a new Terraform configuration file called `www-1.tf`, which will hold the configuration for the Droplet:

[source, hcl-terraform]
----
resource "digitalocean_droplet" "www-1" {
    image = "ubuntu-20-04-x64"
    name = "www-1"
    region = "fra1"
    size = "s-1vcpu-1gb"
    ssh_keys = [
      data.digitalocean_ssh_key.terraform.id
    ]
----

In the preceding configuration, the first line defines a _digitalocean_droplet_ resource named `www-1`. The rest of the lines specify the Droplet’s attributes, including the data center it will be residing in and the slug that identifies the size of the Droplet you want to configure. In this case you’re using `s-1vcpu-1gb`, which will create a Droplet with one CPU and 1GB of RAM. (Visit link:https://slugs.do-api.dev[this size slug chart] to see the available slugs you can use.)

The `ssh_keys` section specifies a list of public keys you want to add to the Droplet. In this case you’re specifying the key you defined in `provider.tf`. Ensure the name here matches the name you specified in `provider.tf`.

When you run Terraform against the DigitalOcean API, it will collect a variety of information about the Droplet, such as its public and private IP addresses. This information can be used by other resources in your configuration.

If you are wondering which arguments are required or optional for a Droplet resource, please refer to the official Terraform documentation: link:http://www.terraform.io/docs/providers/do/r/droplet[DigitalOcean Droplet Specification].

To set up a `connection` that Terraform can use to connect to the server via SSH, add the following lines at the end of the file:

[source, hcl-terraform]
----
# ...

  connection {
    host = self.ipv4_address
    user = "root"
    type = "ssh"
    private_key = file(var.pvt_key)
    timeout = "2m"
  }
----

These lines describe how Terraform should connect to the server, so Terraform can connect over SSH to install Nginx. Note the use of the private key variable `var.pvt_key` - you’ll pass its value in when you run Terraform.

Now that you have the connection set up, configure the `remote-exec` provisioner, which you’ll use to install Nginx. Add the following lines to the configuration to do just that:

[source, hcl-terraform]
----
# ...

  provisioner "remote-exec" {
    inline = [
      "export PATH=$PATH:/usr/bin",
      "sudo apt-get update",
      "sudo apt-get install -y nginx"
    ]
  }
}
----

Note that the strings in the inline array are the commands that the root user will run to install Nginx.

The completed file looks like this:

[source, hcl-terraform]
----
resource "digitalocean_droplet" "www-1" {
  image = "ubuntu-20-04-x64"
  name = "www-1"
  region = "fra1"
  size = "s-1vcpu-1gb"
  ssh_keys = [
    data.digitalocean_ssh_key.terraform.id
  ]

  connection {
    host = self.ipv4_address
    user = "root"
    type = "ssh"
    private_key = file(var.pvt_key)
    timeout = "2m"
  }

  provisioner "remote-exec" {
    inline = [
      "export PATH=$PATH:/usr/bin",
      "sudo apt update",
      "sudo apt install -y nginx"
    ]
  }
}
----

Save the file and exit the editor. You’ve defined the server, and are ready to deploy it, which you’ll now do.

== Step 4 — Using Terraform to Create the Nginx Server
Your current Terraform configuration describes a single Nginx server. You’ll now deploy the Droplet exactly as it’s defined.

Run the `terraform plan` command to see the _execution plan_, or what Terraform will attempt to do to build the infrastructure you described. You will have to specify the values for your DigitalOcean Access Token and the path to your private key, as your configuration uses this information to access your Droplet to install Nginx. Run the following command to create a plan:

[source, bash]
----
terraform plan -var="do_token=<THE_DIGITAL_OCEAN_API_TOKEN>"
----

CAUTION: The terraform plan command supports an -out parameter to save the plan. However, the plan will store API keys, and Terraform does not encrypt this data. When using this option, you should explore encrypting this file if you plan to send it to others or leave it at rest for an extended period of time.

You’ll see output similar to this:

[source, text]
----
OutputTerraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:
  + create

Terraform will perform the following actions:

  # digitalocean_droplet.www-1 will be created
  + resource "digitalocean_droplet" "www-1" {
      + backups              = false
      + created_at           = (known after apply)
      + disk                 = (known after apply)
      + graceful_shutdown    = false
      + id                   = (known after apply)
      + image                = "ubuntu-20-04-x64"
      + ipv4_address         = (known after apply)
      + ipv4_address_private = (known after apply)
      + ipv6                 = false
      + ipv6_address         = (known after apply)
      + locked               = (known after apply)
      + memory               = (known after apply)
      + monitoring           = false
      + name                 = "www-1"
      + price_hourly         = (known after apply)
      + price_monthly        = (known after apply)
      + private_networking   = (known after apply)
      + region               = "fra1"
      + resize_disk          = true
      + size                 = "s-1vcpu-1gb"
      + ssh_keys             = [
          + "...",
        ]
      + status               = (known after apply)
      + urn                  = (known after apply)
      + vcpus                = (known after apply)
      + volume_ids           = (known after apply)
      + vpc_uuid             = (known after apply)
    }

Plan: 1 to add, 0 to change, 0 to destroy.

───────────────────────────────────────────────────────────────

Note: You didn't use the -out option to save this plan, so Terraform can't guarantee to take exactly these actions if you run "terraform apply" now.
----

The + resource "digitalocean_droplet" "www-1" line means that Terraform will create a new Droplet resource called www-1, with the details that follow it. That’s exactly what should happen, so run terraform apply command to execute the current plan.

[source, bash]
----
terraform apply -var="do_token=<THE_DIGITAL_OCEAN_API_TOKEN>"
----

Terraform will provision your Droplet:

[source, text]
----
Output
digitalocean_droplet.www-1: Creating...
----

After a bit of time, you’ll see Terraform installing Nginx with `the remote-exec` provisioner, and then the process will complete:

[source, text]
----
Output

digitalocean_droplet.www-1: Provisioning with 'remote-exec'...

....

digitalocean_droplet.www-1: Creation complete after 1m54s [id=your_www-1_droplet_id]

Apply complete! Resources: 1 added, 0 changed, 0 destroyed.
...
----

Terraform has created a new Droplet called www-1 and installed Nginx on it. If you visit the public IP address of your new Droplet, you’ll see the Nginx welcome screen. The public IP was displayed when the Droplet was created, but you can always view it by looking at Terraform’s current state. Terraform updates the state file terraform.tfstate every time it executes a plan or refreshes its state.

[NOTE]
====
If you modify your infrastructure outside of Terraform, your state file will be out of date. If your resources are modified outside of Terraform, you’ll need to refresh the state file to bring it up to date. This command will pull the updated resource information from your provider(s):

[source, bash]
----
terraform refresh -var="do_token=<THE_DIGITAL_OCEAN_API_TOKEN>"
----
====

In this step, you’ve deployed the Droplet that you’ve described in Terraform. You’ll now create a second one.

== Step 5 — Creating the Second Nginx Server
Now that you have described an Nginx server, you can add a second quickly by copying the existing server’s configuration file and replacing the name and hostname of the Droplet resource.

You can do this manually, but it’s faster to use the `sed` command to read the `www-1.tf` file, substitute all instances of `www-1` with `www-2`, and create a new file called www`-2.tf`. Here is the `sed` command to do that:

[source, bash]
----
sed 's/www-1/www-2/g' www-1.tf > www-2.tf
----

Run `terraform plan` again to preview the changes that Terraform will make.

Run `terraform apply` again to create the second Droplet. After some time, Terraform will create the new server and display the results.

[source, text]
----
Output
digitalocean_droplet.www-2: Creation complete after 1m47s [id=your_www-2_droplet_id]
...
Apply complete! Resources: 1 added, 0 changed, 0 destroyed.
----

Terraform created the new server, while not altering the existing one. You can repeat this step to add additional Nginx servers.

Now that you have two Droplets running Nginx, you’ll define and deploy a load balancer to split traffic between them.

== Step 6 — Creating the Load Balancer
You’ll use a link:https://www.digitalocean.com/products/load-balancer[DigitalOcean Load Balancer], which the official Terraform provider supports, to route traffic between the two web servers.

Create a new Terraform configuration file called `loadbalancer.tf`:

[source, hcl-terraform]
----
resource "digitalocean_loadbalancer" "www-lb" {
  name = "www-lb"
  region = "fra1"

  forwarding_rule {
    entry_port = 80
    entry_protocol = "http"

    target_port = 80
    target_protocol = "http"
  }

  healthcheck {
    port = 22
    protocol = "tcp"
  }

  droplet_ids = [digitalocean_droplet.www-1.id, digitalocean_droplet.www-2.id ]
}
----

The Load Balancer definition specifies its name, the datacenter it will be in, the ports it should listen on to balance traffic, configuration for the health check, and the IDs of the Droplets it should balance, which you fetch using Terraform variables. Save and close the file.

Run `terraform plan` command again to review the new execution plan.

Run `terraform apply` to build the Load Balancer.

Use `terraform show` to locate the IP address of your Load Balancer.

Navigate to `http://your_load_balancer_ip` in your browser and you’ll see an Nginx welcome screen because the Load Balancer is sending traffic to one of the two Nginx servers.

You’ll now learn how to configure DNS for your DigitalOcean account using Terraform.

== Step 7 — Creating DNS Domains and Records
In addition to Droplets and Load Balancers, Terraform can also create DNS domain and record domains. For example, if you want to point your domain to your Load Balancer, you can write the configuration describing that relationship.

Create a new file `domain.tf` to describe your DNS:

[source, hcl-terraform]
----
resource "digitalocean_domain" "playground" {
   name = "playground-digitalocean.test.sommerfeld.io"
   ip_address = digitalocean_loadbalancer.www-lb.ip
}
----

Save and close the file when you’re done.

To add the DNS entries, run `terraform plan` followed by `terraform apply`, as with the other resources.

Navigate to your domain name and you’ll see an Nginx welcome screen because the domain is pointing to the Load Balancer, which is sending traffic to one of the two Nginx servers.

== Step 8 — Destroying Your Infrastructure
Although not commonly used in production environments, Terraform can also destroy infrastructure that it created. This is mainly useful in development environments that are deployed and destroyed multiple times.

[source, bash]
----
terraform destroy -auto-approve
----

Terraform will proceed to destroy the resources.

== Conclusion
In this tutorial, you used Terraform to build a load-balanced web infrastructure on DigitalOcean, with two Nginx web servers running behind a DigitalOcean Load Balancer. You know how to create and destroy resources, view the current state, and use Terraform to configure DNS entries.

Now that you understand how Terraform works, you can create configuration files that describe a server infrastructure for your own projects. The example in this tutorial is a good starting point that demonstrates how you can automate the deployment of servers. If you already use provisioning tools, you can integrate them with Terraform to configure servers as part of their creation process instead of using the provisioning method used in this tutorial.

Terraform has many more features, and can work with other providers. Check out the official http://www.terraform.io/docs/index[Terraform Documentation] to learn more about how you can use Terraform to improve your own infrastructure.

== Further information
The original tutorial is part of the link:https://www.digitalocean.com/community/tutorial_series/how-to-manage-infrastructure-with-terraform[How To Manage Infrastructure with Terraform] series. The series covers a number of Terraform topics, from installing Terraform for the first time to managing complex projects.

Next in the series: link:https://www.digitalocean.com/community/tutorials/how-to-structure-a-terraform-project[How To Structure a Terraform Project]

* DigitalOcean Provider -> https://registry.terraform.io/providers/digitalocean/digitalocean/latest/docs